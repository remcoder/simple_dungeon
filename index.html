<html>
  <!DOCTYPE html>
<style>
* {
  box-sizing: border-box;
}
body {
  background: #000;
  overflow: hidden;
}
h1 {
  color: brown;
  text-align: center;
}
.scene {
  perspective: 400px;
  margin: auto;
  width: 200px;
  height: 200px;

  background: #000;
  overflow: hidden;
  transform-origin: top;
  transform: scale(3);
}

.camera {
  position: absolute;
  transform-style: preserve-3d;
  transition: transform 3s linear;
}

.tile {
  position: absolute;
  background: #888;
  width: 200px; height: 200px;
  transform-style: preserve-3d; 
  box-sizing: border-box;
  backface-visibility: visible;
  text-align: center;
  font-size: 200%;
  padding-top:40%;
  font-weight: bold;
}

.back {
  transform: translateZ(-200px);
}

.front {
  transform: translateZ(0);
}

.floor {
  transform-origin: bottom;
  transform: rotateX(90DEG);
}

.ceiling {
  transform-origin: top;
  transform: rotateX(-90deg);
}

.left {
  transform-origin: left;
  transform: rotateY(90deg);
}

.right {
  transform-origin: right;
  transform: rotateY(-90deg);
}

.wall {
  background: url("tiles/wall.png");
}

.floor {
  background: url("tiles/floor.png");
  xbackground: #888;
  background-size: 100%;
}

.cell {
  transform-style: preserve-3d; 
}

#map {
  position: absolute;
  right: 2px;
  bottom: 2px;
  transform-origin: center;
}

#map2 {
  position: absolute;
  right: 2px;
  bottom: 2px;
}

.map-cell {
  position: absolute;
  opacity: 0.5;
}

.map-cell.rendered {
  opacity: 1;
}

.map-cell.wall { background-size: 100%; }

.player {
  background: blue;
}

</style>
<body>
  <div id="app">
  <h1>{{ title }}</h1>

  <div class="scene">
    <div class="camera " :class="{walking : walking}">

      <div class="cell" v-for="(cell,index) in rotate(cells)" v-if="visible(cell)"
        :style="{transform : transform(cell) }">
          <!-- <div class="tile back wall"></div> -->
          <div v-if="cell.floor" 
            class="tile floor" 
            :style="{filter : brightness(cell) }" >
            {{index}}
          </div>
          <!-- <div v-if="cell.floor" class="tile ceiling" :style="{filter : brightness(cell) }" ></div> -->
          <div v-if="cell.wall" class="tile left wall" :style="{filter : brightness(cell) }"></div>
          <div v-if="cell.wall" class="tile right wall" :style="{filter : brightness(cell) }"></div>
          <div v-if="cell.wall" class="tile back wall" :style="{filter : brightness(cell) }"></div>
          <div v-if="cell.wall" class="tile front wall" :style="{filter : brightness(cell) }"></div>
      </div>

    </div>
  </div>

  <div id="map" class="map" :style="{width: mapSize, height: mapSize}">
    <div class="map-cell" 
      v-for="(cell,index) in translate(cells)"
      :class="getTileType(cell)" 
      :style="{
        transform : mapTransform(cell), 
        width : mapCellSize()+'px',
        height : mapCellSize()+'px'
      }">
      <!-- {{index}} -->
    </div>
  </div>

  <!-- <div id="map2" class="map" :style="{width: mapSize, height: mapSize}">
    <div class="map-cell" 
      v-for="(cell,index) in rotate(cells)"
      :class="getTileType(cell)" 
      :style="{
        transform : mapTransform(cell), 
        width : mapCellSize()+'px',
        height : mapCellSize()+'px'
      }">
      {{index}}
    </div>
  </div>  -->

</div>
<!-- development version, includes helpful console warnings -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<!-- production version, optimized for size and speed -->
<!-- <script src="https://cdn.jsdelivr.net/npm/vue"></script> -->

  <script>
  const cellSize = 200;
  const WALL = "#";
  const FLOOR = ".";
//   const map = [
// '#.#.',
// '....',
// '#...',
// '....',
// ];
  const map = [
'..#####.....',
'..#..##.....',
'.#....#.....',
'..#...#.....',
'..#....#....',
'..#....#....',
'..#...#.....',
'##...######.',
'#..........#',
'#..........#'];

  

  var app = new Vue({
  el: '#app',
  data: {
    title: 'Simple Dungeon',
    walking: false,
    cells: processMap(map),
    camera: {
      position: {
        row : 9,
        column: 2
      },
      angle : 0
    },
    mapSize : 200,
  },
  methods :  {
    handleKeyDown(evt) {
      var row, cell;
      // console.log(evt, evt.key)
      switch(evt.key) {
        case "ArrowUp":
          this.moveInDirection(this.camera.angle);
          break;
        
        case "ArrowDown": 
          this.moveInDirection((this.camera.angle + 2) % 4 );
          break;
        
        case "ArrowLeft":
          if (evt.altKey)
            this.moveInDirection((this.camera.angle + 3) % 4 );
          else
            this.camera.angle = (this.camera.angle + 4 -1) % 4;
          console.log(this.camera.angle)
          // if (map[this.camera.position.row][this.camera.position.column-1] == FLOOR)
          //   this.camera.position.column--
          break;
        
        case "ArrowRight": 
          if (evt.altKey)
            this.moveInDirection((this.camera.angle + 1) % 4 );
          else
            this.camera.angle = (this.camera.angle + 1) % 4;
          console.log(this.camera.angle)
          // if (map[this.camera.position.row][this.camera.position.column+1] != WALL)
          //   this.camera.position.column++
          break;
      }
    },

    moveInDirection(angle) {
      console.log("move to " + angle)
      switch (angle) {
          case 0:
            this.move(0,-1)
            break;
          case 1:
            this.move(1,0);
            break;
          case 2:
            this.move(0,1);
            break;
          case 3:
            this.move(-1,0);
            break;
        }
    },

    move(dx,dy) {
      const newRow = this.camera.position.row + dy
      const row = map[newRow];
      if (!row) return;
      const newColumn = this.camera.position.column + dx
      const cell = row[newColumn];
      
      if (cell == FLOOR) { 
        this.camera.position.row = newRow;
        this.camera.position.column = newColumn;
      }

      document.title = `x:${newColumn}, y:${newRow}`;
    },

    brightness(cell) {
      var dx = cell.rowIndex;
      var dy = cell.cellIndex;
      var d = Math.sqrt(dx*dx + dy*dy);
      var b = Math.pow(1.2,-1-d);
      var s = `brightness(${b})`;
      return s;
    },

    transform(cell) {
      var mapSize = map.length-1;
      var dx = (cell.cellIndex + mapSize) % mapSize;
      var dz = cell.rowIndex + 0.9;
      var t = `translate3d(${ cell.cellIndex*cellSize }px, 0px, ${ dz*cellSize }px)`;
      return t;
    },
    
    visible(cell) {
      return cell.rowIndex <= 0;
    },

    mapTransform(cell) {
      // console.log(cell.cellIndex, cell.rowIndex);
      const size = this.mapCellSize();
      const x = cell.cellIndex * size;
      const y = cell.rowIndex * size;
      const t= `translate3d(${x}px, ${y}px, 0px)`;
      return t;
    },

    getTileType(cell) {
      const pos = this.camera.position;
      const classList = [];
      if (cell.rowIndex == 0 && cell.cellIndex == 0)
        classList.push("player");
      if (cell.wall)
        classList.push("wall");
      if (cell.floor)
        classList.push("floor");
      if (this.visible(cell))
        classList.push("rendered");
      return classList
    },

    mapCellSize() {
      return this.mapSize / map.length;
    },

    rotate(cells) {
      var rotated;
      var max = map.length-1;
      return cells.map(c => {
        switch (this.camera.angle) {
          case 0: // 0 degrees
             rotated = Object.assign({}, c);
             rotated.rowIndex = c.rowIndex - this.camera.position.row;
             rotated.cellIndex = c.cellIndex - this.camera.position.column;
             return rotated
          case 1: // 90 degrees
             rotated = Object.assign({}, c);
             rotated.cellIndex = c.rowIndex - this.camera.position.row;
             rotated.rowIndex = max - c.cellIndex - (max - this.camera.position.column);
             return rotated
          case 2: // 180 degrees
          rotated = Object.assign({}, c);
          rotated.cellIndex = max - c.cellIndex - (max - this.camera.position.column);
             rotated.rowIndex = max - c.rowIndex - (max - this.camera.position.row);
             return rotated
            break;
          case 3: // 270 degrees
          rotated = Object.assign({}, c);
             rotated.cellIndex = max - c.rowIndex - (max - this.camera.position.row);
             rotated.rowIndex = c.cellIndex - this.camera.position.column;
             return rotated
            break;
        }
      });
    },

    translate(cells) {
      var rotated;
      var max = map.length-1;
      return cells.map(c => {
        rotated = Object.assign({}, c);
        rotated.rowIndex = c.rowIndex - this.camera.position.row;
        rotated.cellIndex = c.cellIndex - this.camera.position.column;
        return rotated
      });
    }
  },
  mounted() {
    this.move(0,0);
    document.addEventListener('keydown', this.handleKeyDown);
  },
})

function processMap(map) {
  var cells = [];
  map.forEach((r,rowIndex) => { 
    r.split("").forEach((c,cellIndex)=>{
      cells.push({
        rowIndex,
        cellIndex,
        wall : c == "#",
        floor : c == "."
      });
    });
  });
  return cells;
}

  </script>

</body>
</html>